# [자바와 JUnit을 활용한 실용주의 단위 테스트](http://www.yes24.com/Product/Goods/75189146?scode=032&OzSrank=1)
## 목차
### [1장 첫 번째 JUnit 테스트 만들기]()
- **1. 단위 테스트를 작성하는 이유**
- **2. JUnit의 기본: 첫 번째 테스트 통과**
- **3. 테스트 준비, 실행, 단언**
- **4. 테스트가 정말로 뭔가를 테스트하는가?**
- **5. 마치며**

### [2장 JUnit 진짜로 써 보기]()
- **1. 테스트 대상 이해: Profile 클래스**
- **2. 어떤 테스트를 작성할 수 있는지 결정**
- **3. 단일 경로 커버**
- **4. 두 번째 테스트 만들기**
- **5. @Before 메서드로 테스트 초기화**
- **6. 이제 어떤가?**
- **7. 마치며**

### [3장 JUnit 단언 깊게 파기]()
- **1. JUnit 단언**
- **2. 예외를 기대하는 세 가지 방법**
- **3. 마치며**

### [4장 테스트 조직]()
- **1. AAA로 테스트 일관성 유지**
- **2. 동작 테스트 vs 메서드 테스트**
- **3. 테스트와 프로덕션 코드의 관계**
- **4. 집중적인 단일 목적 테스트의 가치**
- **5. 문서로서의 테스트**
- **6. @Before와 @After (공통 초기화와 정리) 더 알기**
- **7. 녹색이 좋다: 테스트를 의미 있게 유지**
- **8. 마치며**

### [5장 좋은 테스트의 FIRST 속성]()
- **1. FIRST: 좋은 테스트 조건**
- **2. [F]IRST: 빠르다**
- **3. F[I]RST: 고립시킨다**
- **4. FI[R]ST: 좋은 테스트는 반복 가능해야 한다**
- **5. FIR[S]T: 스스로 검증 가능하다**
- **6. FIRS[T]: 적시에 사용한다**
- **7. 마치며**

### [6장 Right-BICEP: 무엇을 테스트할 것인가?]()
- **1. [Right]-BICEP: 결과가 올바른가?**
- **2. Right-[B]ICEP: 경계 조건은 맞는가?**
- **3. 경계 조건에서는 CORRECT를 기억하라**
- **4. Right-B[I]CEP: 역 관계를 검사할 수 있는가?**
- **5. Right-BI[C]EP: 다른 수단을 활용하여 교차 검사할 수 있는가?**
- **6. Right-BIC[E]P: 오류 조건을 강제로 일어나게 할 수 있는가?**
- **7. Right-BICE[P]: 성능 조건은 기준에 부합하는가?**
- **8. 마치며**

### [7장 경계 조건: CORRECT 기억법]()
- **1. [C]ORRECT: [C]onformance(준수)**
- **2. C[O]RRECT: [O]rdering(순서)**
- **3. CO[R]RECT: [R]ange(범위)**
- **4. COR[R]ECT: [R]eference(참조)**
- **5. CORR[E]CT: [E]xistence(존재)**
- **6. CORRE[C]T: [C]ardinality(기수)**
- **7. CORREC[T]: [T]ime(시간)**
- **8. 마치며**

### [8장 깔끔한 코드로 리팩토링하기]()
- **1. 작은 리팩토링**
- **2. 메서드를 위한 더 좋은 집 찾기**
- **3. 자동 및 수동 리팩토링**
- **4. 과한 리팩토링?**
- **5. 마치며**

### [9장 더 큰 설계 문제 ]()
- **1. Profile 클래스와 SRP**
- **2. 새로운 클래스 추출**
- **3. 명령-질의 분리**
- **4. 단위 테스트의 유지 보수 비용**
- **5. 다른 설계에 관한 생각들**
- **6. 마치며**

### [10장 목 객체 사용]()
- **1. 테스트 도전 과제**
- **2. 번거로운 동작을 스텁으로 대체**
- **3. 테스트를 지원하기 위한 설계 변경**
- **4. 스텁에 지능 더하기: 인자 검증**
- **5. 목 도구를 사용하여 테스트 단순화**
- **6. 마지막 하나의 단순화: 주입 도구 소개**
- **7. 목을 올바르게 사용할 때 중요한 것**
- **8. 마치며**

### [11장 테스트 리팩토링]()
- **1. 이해 검색**
- **2. 테스트 냄새: 불필요한 테스트 코드**
- **3. 테스트 냄새: 추상화 누락**
- **4. 테스트 냄새: 부적절한 정보**
- **5. 테스트 냄새: 부푼 생성**
- **6. 테스트 냄새: 다수의 단언**
- **7. 테스트 냄새: 테스트와 무관한 세부 사항들**
- **8. 테스트 냄새: 잘못된 조직**
- **9. 테스트 냄새: 암시적 의미**
- **10. 새로운 테스트 추가**
- **11. 마치며**

### [12장 테스트 주도 개발]()
- **1. TDD의 주된 이익**
- **2. 단순하게 시작**
- **3. 또 다른 증분 추가**
- **4. 테스트 정리**
- **5. 또 다른 작은 증분**
- **6. 다수의 응답 지원: 작은 설계 우회로**
- **7. 인터페이스 확장**
- **8. 마지막 테스트들**
- **9. 문서로서의 테스트**
- **10. TDD의 리듬**
- **11. 마치며**

### [13장 까다로운 테스트 ]()
- **1. 멀티스레드 코드 테스트**
- **2. 데이터베이스 테스트**
- **3. 마치며**

### [14장 프로젝트에서 테스트]()
- **1. 빠른 도입**
- **2. 팀과 같은 편 되기**
- **3. 지속적 통합으로 수렴**
- **4. 코드 커버리지**
- **5. 마치며**

---

## 스터디 일정
#### 1주차(2019.07.21)
- 1장 첫 번째 JUnit 테스트 만들기 
- 2장 JUnit 진짜로 써 보기 
- 3장 JUnit 단언 깊게 파기

#### 2주차(2019.07.28)
- 4장 테스트 조직
- 5장 좋은 테스트의 FIRST 속성

#### 3주차(2019.08.04)
- 6장 Right-BICEP: 무엇을 테스트할 것인가? 
- 7장 경계 조건: CORRECT 기억법

#### 4주차(2019.08.11)
- 8장 깔끔한 코드로 리팩토링하기
- 9장 더 큰 설계 문제 

#### 5주차(2019.08.18)
- 10장 목 객체 사용
- 11장 테스트 리팩토링

#### 6주차(2019.08.25)
- 12장 테스트 주도 개발

#### 7주차(2019.09.01)
- 13장 까다로운 테스트 
- 14장 프로젝트에서 테스트

#### 8주차(2019.09.08)
- [문자열 계산기](https://github.com/wwh-techcamp-2018/java-racingcar/tree/team1_pair1/src/main/java/calculator)를 이용한 테스트코드 구현 

#### 9주차(2019.09.15)
- [레이싱 카](https://github.com/wwh-techcamp-2018/java-racingcar/tree/team1_pair1/src/main/java/racing)를 이용한 테스트코드 구현 

#### 10주차(2019.09.22)
- [로또](https://github.com/wwh-techcamp-2018/java-lotto/tree/team1_pair1)를 이용한 테스트코드 구현 

#### 11주차(2019.09.29)
- [로또](https://github.com/wwh-techcamp-2018/java-lotto/tree/team1_pair1)를 이용한 테스트코드 구현 