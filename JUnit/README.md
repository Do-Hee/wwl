# [자바와 JUnit을 활용한 실용주의 단위 테스트](http://www.yes24.com/Product/Goods/75189146?scode=032&OzSrank=1)
## 목차
### [1장 첫 번째 JUnit 테스트 만들기]()
- **1 단위 테스트를 작성하는 이유**
- **2 JUnit의 기본: 첫 번째 테스트 통과**
- **3 테스트 준비, 실행, 단언**
- **4 테스트가 정말로 뭔가를 테스트하는가?**
- **5 마치며**

### [2장 JUnit 진짜로 써 보기]()
- **1 테스트 대상 이해: Profile 클래스**
- **2 어떤 테스트를 작성할 수 있는지 결정**
- **3 단일 경로 커버**
- **4 두 번째 테스트 만들기**
- **5 @Before 메서드로 테스트 초기화**
- **6 이제 어떤가?**
- **7 마치며**

### [3장 JUnit 단언 깊게 파기]()
- **1 JUnit 단언**
- **2 예외를 기대하는 세 가지 방법**
- **3 마치며**

### [4장 테스트 조직]()
- **1 AAA로 테스트 일관성 유지**
- **2 동작 테스트 vs 메서드 테스트**
- **3 테스트와 프로덕션 코드의 관계**
- **4 집중적인 단일 목적 테스트의 가치**
- **5 문서로서의 테스트**
- **6 @Before와 @After (공통 초기화와 정리) 더 알기**
- **7 녹색이 좋다: 테스트를 의미 있게 유지**
- **8 마치며**

### [5장 좋은 테스트의 FIRST 속성]()
5.1 FIRST: 좋은 테스트 조건
5.2 [F]IRST: 빠르다
5.3 F[I]RST: 고립시킨다
5.4 FI[R]ST: 좋은 테스트는 반복 가능해야 한다
5.5 FIR[S]T: 스스로 검증 가능하다
5.6 FIRS[T]: 적시에 사용한다
5.7 마치며

### [6장 Right-BICEP: 무엇을 테스트할 것인가?]()
6.1 [Right]-BICEP: 결과가 올바른가?
6.2 Right-[B]ICEP: 경계 조건은 맞는가?
6.3 경계 조건에서는 CORRECT를 기억하라
6.4 Right-B[I]CEP: 역 관계를 검사할 수 있는가?
6.5 Right-BI[C]EP: 다른 수단을 활용하여 교차 검사할 수 있는가?
6.6 Right-BIC[E]P: 오류 조건을 강제로 일어나게 할 수 있는가?
6.7 Right-BICE[P]: 성능 조건은 기준에 부합하는가?
6.8 마치며

### [7장 경계 조건: CORRECT 기억법]()
7.1 [C]ORRECT: [C]onformance(준수)
7.2 C[O]RRECT: [O]rdering(순서)
7.3 CO[R]RECT: [R]ange(범위)
7.4 COR[R]ECT: [R]eference(참조)
7.5 CORR[E]CT: [E]xistence(존재)
7.6 CORRE[C]T: [C]ardinality(기수)
7.7 CORREC[T]: [T]ime(시간)
7.8 마치며

### [8장 깔끔한 코드로 리팩토링하기]()
8.1 작은 리팩토링
8.2 메서드를 위한 더 좋은 집 찾기
8.3 자동 및 수동 리팩토링 
8.4 과한 리팩토링? 
8.5 마치며

### [9장 더 큰 설계 문제 ]()
9.1 Profile 클래스와 SRP
9.2 새로운 클래스 추출 
9.3 명령-질의 분리
9.4 단위 테스트의 유지 보수 비용
9.5 다른 설계에 관한 생각들
9.6 마치며 

### [10장 목 객체 사용]()
10.1 테스트 도전 과제
10.2 번거로운 동작을 스텁으로 대체
10.3 테스트를 지원하기 위한 설계 변경
10.4 스텁에 지능 더하기: 인자 검증
10.5 목 도구를 사용하여 테스트 단순화
10.6 마지막 하나의 단순화: 주입 도구 소개
10.7 목을 올바르게 사용할 때 중요한 것
10.8 마치며

### [11장 테스트 리팩토링]()
11.1 이해 검색
11.2 테스트 냄새: 불필요한 테스트 코드
11.3 테스트 냄새: 추상화 누락
11.4 테스트 냄새: 부적절한 정보
11.5 테스트 냄새: 부푼 생성
11.6 테스트 냄새: 다수의 단언 
11.7 테스트 냄새: 테스트와 무관한 세부 사항들
11.8 테스트 냄새: 잘못된 조직
11.9 테스트 냄새: 암시적 의미 
11.10 새로운 테스트 추가
11.11 마치며

### [12장 테스트 주도 개발]()
12.1 TDD의 주된 이익
12.2 단순하게 시작
12.3 또 다른 증분 추가
12.4 테스트 정리
12.5 또 다른 작은 증분
12.6 다수의 응답 지원: 작은 설계 우회로
12.7 인터페이스 확장
12.8 마지막 테스트들
12.9 문서로서의 테스트
12.10 TDD의 리듬
12.11 마치며

### [13장 까다로운 테스트 ]()
13.1 멀티스레드 코드 테스트 
13.2 데이터베이스 테스트
13.3 마치며

### [14장 프로젝트에서 테스트]()
14.1 빠른 도입
14.2 팀과 같은 편 되기
14.3 지속적 통합으로 수렴 
14.4 코드 커버리지
14.5 마치며

---

## 스터디 일정
#### 1주차(2019.07.21)
- 1장 첫 번째 JUnit 테스트 만들기 
- 2장 JUnit 진짜로 써 보기 

#### 2주차(2019.07.28)
- 3장 JUnit 단언 깊게 파기

#### 3주차(2019.08.04)
- 4장 테스트 조직

#### 4주차(2019.08.11)
- 5장 좋은 테스트의 FIRST 속성
- 6장 Right-BICEP: 무엇을 테스트할 것인가? 
- 7장 경계 조건: CORRECT 기억법

#### 5주차(2019.08.18)
- 8장 깔끔한 코드로 리팩토링하기

#### 6주차(2019.08.25)
- 9장 더 큰 설계 문제 

#### 7주차(2019.09.01)
- 10장 목 객체 사용

#### 8주차(2019.09.08)
- 11장 테스트 리팩토링

#### 9주차(2019.09.15)
- 12장 테스트 주도 개발

#### 10주차(2019.09.22)
- 13장 까다로운 테스트 

#### 11주차(2019.09.29)
- 14장 프로젝트에서 테스트
