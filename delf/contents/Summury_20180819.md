# 자바 웰 프로그래밍 NextStep
너무 적게 진행한다는 피드백이 있어서 이번에는 세 장을 진행해 보았다. 소화할 만했던 것 같다.
## [10장](https://github.com/T-WWL/WWL/blob/master/delf/contents/JavaWebProgrammingNetxtStep/20180819_Chapter10.md)
### 자바의 리플렉션과 애노테이션
- 자바의 리플렉션에 대해 알 수 있었다. 당장 능숙하게 사용할 정도는 아니었지만, "아 런타임 때 이런것도 가능하구나"라는 걸 알았고, 써먹을 곳이 많겠다고 생각했다.
- 스프링의 @Controller 애노테이션이 어떻게 돌아가는지 감을 잡았다. 애노테이션 달린 클래스를 인식해서 자동으로 객체를 생성했었는데, 이걸  직접 구현해보니 이해가 쉬웠다.

### 인터페이스를 이용한 확장성 있는 설계
여러가지 프레임워크에 해당하는 컨트롤러를 동시에 운용하기 위해 인터페스를 구현해 확장성 있게 구현해보았다.
- 이 챕터에서 강조하는 것은 <u>서비스를 중단하지 않은 채 점진적으로 코드를 개선 해 나가는 것</u>이었다.
- 언뜻 보이면 "불필요해보이고 귀찮은 과정"을 거치는 것 같지만, 좀더 규모가 큰 프로젝트라면 이런 과정이 필요하다고 납득했다.
- 코드의 동작 방식은 이해했지만, 과연 같은 상황이 왔을 때 내가 이런 방식으로 구현하는 것을 떠올려낼지는 의문이다.
- 아마 [희정이가 저번 주에 공부](https://github.com/T-WWL/WWL/blob/master/hee/contents/180812-bookstudy.md#%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4)한 [템플릿 메서드 패턴](https://gmlwjd9405.github.io/2018/07/13/template-method-pattern.html)인듯 싶다.

## [11장](https://github.com/T-WWL/WWL/blob/master/delf/contents/JavaWebProgrammingNetxtStep/20180819_Chapter11.md)
특이하게도 "DI는 쓰레기이다. 책을 집어던져라." 라고 표현한 챕터. 아마 지금에 있어서 학습 우선순위가 밀린다는걸 말하고 싶었던 듯 하다. 그래서 코드를 짜보진 않고 천천히 읽어보았다.
### [의존성 주입](https://github.com/T-WWL/WWL/blob/master/delf/contents/JavaWebProgrammingNetxtStep/20180819_Chapter11.md#111-%EC%99%9C-di%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80)
의존성 주입에 관해서는 학교 수업으로 배운 경험이 있지만, 이 챕처를 읽고나니 그때는 @Inject 애노테이션만 배웠다는 생각이든다.
- 나 역시 과거의 저자와 같이 아직까지는 완벽하게 DI의 필요성을 느끼지 못하고 있다.
- 이러한 의존성 주입은 내가 도연이와 같이 미니프로젝트(타이핑 게임)를 진행할 때 겪은 문제였다.
    - 더 많은 화면(프레임과 패널)를 만들 수록 그 화면에는 이전 화면에 대한 객체를 가지고 있었고, 새로운 객체를 생성할때마다 이전 화먄에 대한 객체를 전달해했다. 그 구조가 그당시에는 매우 이질적이게 느껴졌다.
    - 당시에는 화면을 관리하는 객체를 따로 만들었고 거기서 ststic으로 선언한 화면객체 가져와서 사용했다. 사실 static 객체를 선언하고 사용한다는 것도 거부감이 들었지만 당시에 최선의 선택이라고 여겨졌다.
    - 지금 생각해보면 그 화면을 관리하는 객체가 BeanFactory정도 될 수 있었겠지만, 큰 차이는 객체에 관한 의존성을 주입하고 관리한까지 한다는 것이겠지.
### [객체지향적 설계](https://github.com/T-WWL/WWL/blob/master/delf/contents/JavaWebProgrammingNetxtStep/20180819_Chapter11.md#1133-di%EB%B3%B4%EB%8B%A4-%EC%9A%B0%EC%84%A0%ED%95%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EA%B0%9C%EB%B0%9C)
- "도메인 객체가 더 많은 일을 담당해야한다." 는건 내가 가지고 있던 SRP의 개념과 약간 상충됐다. 의도한 바는 아니였지만 확실히 도메인 객체는 말 그대로 
'상태 값만 담고있는 데이터 집합'으로만 짰던거 같다. 앞으로는 좀 더 생각해야 겠다.

## [12장](https://github.com/T-WWL/WWL/blob/master/delf/contents/JavaWebProgrammingNetxtStep/20180819_Chapter12.md)
11장에 이어서 DI 프레임워크에 대한 개선 내용이었다. 생성자에서 뿐만 아니라, 필드와 setter 메소드로도 의존성을 주입하는 방법을 추가하고 이것을 템플릿 메서드 패턴으러 추상화하고 정리한 과정을 다룬다. 

앞 장을 직접 구현해보지 않았기에, 따라가기는 더더욱 무리. 역시 정독했다.

- 구현을 구체화할수록 점점 스프링 프레임워크의 형식과 닮아가는 것을 느꼈다. 내가 스프링 프레임워크를 이해하고 있다는건 아니지만, 반대로 구현하는걸 보면서 어떻게 돌아가는지 파악할 수 있는계기가 되었다.
- "스프링 프레임워크는 객체지향 설계 관점에서 배울 것이 많은 코드"이리는 표현이 있는데, 맞는 것 같다.

기회가 된다면 11장과 12장은 다시한번 보고 직접 구현해보는 기회를 가져야겠다.

# 알고리즘 문제
## 카카오 코드 페스티벌 예선
#### 부끄럽게도 내가 진짜 풀 수 있는 문제는 예선 때 풀었던 문제가 전부였다. 
다시 풀이를 시도하였지만... 어려웠다. 알고리즘 개념도 개념이었지만 그 외에 수학과 논리적인 측면에 대한게 부족한듯 싶었다. 자괴감이 들었지만, 그래도 부족하나마 다른 알고리즘 문제를 풀기로 했다.

### 매일프로그래밍에서 제출한 알고리즘 풀이
[실리콘밸리 패키지 문제20](https://github.com/Delf-Lee/Daily-Programing/blob/master/src/main/java/DP017/Question_017.md)
[실리콘밸리 패키지 문제20](https://github.com/Delf-Lee/Daily-Programing/blob/master/src/main/java/DP017/Question_018.md)