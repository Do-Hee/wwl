# 10장 새로운 MVC 프레임워크 구현을 통한 점진적인 개선
- 새로운 프레임워크 기술을 적용할 때 어려운 점은 <u>새로운 프레임워크 또는 새로운 기능을 추가하는 작업</u>이 아닌 애플리케이션이 제공하는 기능은 똑같은데 <u>기존 프로엠워크의 한계를 극복하기 위해 개발자의 관점에서 새로운 기술을 적용하는 것</u>. 
- 새로운 애플리케이션을 개발하는 작업운 쉽지 않지만 그보다 더 어려운 작업은 누군가 개발해 놓은 애플리케이션을 지속적으로 기능 추가, 개선을 하면서 기술적으로 계속해서 발전시켜나가는 것.

## 10.1 MVC프레임워크 요구사항 3단계
10~12장보다 한 단계 난이도가 높아진다. 자바 리플렉션 API에 대한 활용과 구현해야할 클래스가 많을 예정.
### 10.1.1 요구사항
1. 새로운 기능이 추가될 때마나 매번 컨트롤러를 추가하는 것이 아니라 메소드를 추가하는 방식
2. 요청 URL을 매핑할 때 HTTP 메소드(GET, POST, PUT, DELETE 등)도 매팔에 활용할 수 있으면 좋겠다.

이 모든 과정을 <u>점진적으로 리펙토링</u> 하는 경험이 이 장의 핵심. 레거시 코드(컨트롤러)와 공존하도록 만들면서, 그 두 가지 형태의 컨트롤러가 모두 동작하도록 구현할 것.초

### 10.1.2 자바 리플렉션
- [[블로그]Java Reflection 개념 및 사용법](http://gyrfalcon.tistory.com/entry/Java-Reflection)
1. 자바 리플렉션 API 활용해 클래스 정보 출력하기
```
@Test
public void showClass() {
    Class<Question> clazz = Question.class;
    logger.debug(clazz.getName());
    Field[] fields = clazz.getDeclaredFields();
    for (int i = 0; i < fields.length; i++) logger.debug(fields[i].getName());
    Method[] methods = clazz.getMethods();
    for (int i = 0; i < methods.length; i++) logger.debug(methods[i].getName());
    Constructor<Question>[] constructor = (Constructor<Question>[]) clazz.getDeclaredConstructors();
    for (int i = 0; i < constructor.length; i++) logger.debug(constructor[i].getName());
}
```
2. test로 시작하는 메소드 실행하기
```
@Test
public void run() throws Exception {
    Class<Junit3Test> clazz = Junit3Test.class;
    Method[] methods = clazz.getMethods();
    for (int i = 0; i < methods.length; i++) {
        if (methods[i].getName().startsWith("test")) {
            methods[i].invoke(clazz.newInstance());
        }
    }
}
```
3. @MyTest 애노테이션을 설정된 메소드 실행하기
```
@Test
public void run() throws Exception {
    Class<Junit4Test> clazz = Junit4Test.class;
    Method[] methods = clazz.getMethods();
    for (Method method : methods) {
        if (method.isAnnotationPresent(MyTest.class)) {
            method.invoke(clazz.newInstance());
        }
    }
}
```
4. 생성자가 있는 클래스의 인스턴스 생성하기
```
@Test
public void newInstanceWithConstructorArgs() throws IllegalAccessException, InvocationTargetException, InstantiationException {
    Class<User> clazz = User.class;
    logger.debug(clazz.getName());
    Constructor<User>[] constructors = (Constructor<User>[]) clazz.getDeclaredConstructors();
    User user = constructors[0].newInstance("id", "pass", "name", "email");
}
```
5. private 필드에 접근하기
```
@Test
public void privateFieldAccess() throws NoSuchFieldException, IllegalAccessException {
    Class<Student> clazz = Student.class;
    logger.debug(clazz.getName());
    Student student = new Student();
    Field nameField = clazz.getDeclaredField("name"); // NoSuchFieldException
    nameField.setAccessible(true);
    nameField.set(student, "데르프"); // IllegalAccessException
    logger.debug("name: " + student.getName());
}

```
### 10.1.3 요구사항 분리 및 힌트
- reflections 라이브러리를 통해 @Controller 애노테이션이 설정되어 있는 모든 클래스를 찾고, 각 클래스에 대한 인스턴스 생성을 담당하는 ControllerScanner클래스를 추가.
    - [?]`controllers.put(clazz, clazz.newInstance());`에서 key가 clazz인 이유?
- 애노테이션 기반 매핑을 담당할 AnnotaionHandlerMapping클래스를 추가한 후 초기화.
- AnnotaionHandlerMapping 클래스에 클라이언트 요청정보(HttpServletRequest)를 전달하면 요청에 해당하는 HandlerExcution을 반환하는 메소드를 구현.

## 10.2 MVC 르래임워크 구현 3단계
### 10.2.1 @Controller 애노테이션 설정 클래스 스캔
@Controller 애노테잉션 설정이 되어있는 클래스 찾기.
---

### 기타
- `map = new Hashmap();` 보다 `map = Maps.newHashmap();`을 쓰는 이유?

