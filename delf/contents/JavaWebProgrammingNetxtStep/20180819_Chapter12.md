# 12장 확장성 있는 DI 프레임워크로 개선
## 12.1 필드와 setter 메소드에 @Inject 기능 추가
- BeanFactory의 역할은 빈을 추가하고 조회하는 역할만 남기고 생성자를 활용해 DI를 하고 인스턴스를 생성하는 역학은 ConstructorInjector라는 이름으로 분리한다.
- Injector라는 인터페이스 추가. 이 인터페이스는 생성자, 필드, setter 메소드 DI에 대한 추상 메소드로 inject()를 가진다.
- 생성자, 필드, setter 메소드에 대한 DI를 담당하는 클래스를 구한한다. 이 구현 클래스는 Injector 인터페이스를 구현한다.
- BeanFacotory는 BeanScanner를 통해 찾은 모든 빈 클래스에 대해 앞에서 구현한 3개의 Injector를 활용해 DI를 진행한다.
    - 3개의 Injector구현체를 구현하면 많은 중복이 발생한다. Injector 인터페이스와 3개의 구현체 사이에 AbstractInjector와 같은 추상 클래스를 생성해 중복을 제거한다.

## 12.2 필드와 setter 메소드 @Inject 구현
## 12.3 @Inject 개선
- 현재 모든 빈과 관련한 정보는 BeanFactory가 관리하고 있는데, 빈 인스턴스 생성과 주입 작업을 Injector 구현 클래스가 담당하다 보니 BeanFactory에게 일을 시키는 것이 아니라 빈 정보를 조회하는 상황이 계속 발생한다.
- 빈 인스턴스 생성과 주입 작업은 BeanFactory가 담당하고, 현재 빈 클래스의 상태 정보를 별도의 클래스로 추상화해 관리하는 것이 좀더 객체지향적인 개발이 가능하갰다.

객체지향 설계의 핵심은 객체의 역할과 책임에 대해 계속해서 고민하면서 한 가지 역할과 책임을 가지도록 하는 것이다. 초반 설계와 구현 단계에서 구체화할 수 있는 부분까지 최대한 명황하게 설계해야겠지만 이는 거의 불가능하다. 초반 설계를 철저히 하는 것도 중요하지만 그 보다 애플리케이션은 언제든지 변경될 수 있다는 가정 하에 변경이 발생했을 때 빠르게 대처할 수 있는 리펙토링 역할을 쌓는 것이 더 중요하다.

상대방이 구현한 코드를 무조건적을 받받아들이지 말고 비판적인 시각으로 바라볼때 자신만의 색깔을 만들 수 있고 역량을 키울 수 있다.

## 12.4 설정 추가를 통한 유연성 확보
- 패키지 명을 외부에서 전달할 수 있도록 구현
- 각 레이어에 명확히 일치하지 않는 빈을 지원하는 에노테이션 추가
- 데이터베이스에 종속되지 않도록 구현하고 Connection Pooling을 지원.

## 12.5 외부 라이브러리 클래스를 빈으로 등록
개발자가 직접 빈을 생성해 관리할 수 있는 별도의 설정파일을 제작

## 12.6 초기화 기능 추가
빈을 등록할 때 초기화 작업 필요. 애노테이션을 이용하여 초기화 설정 지원

## 12.7 인터페이스, DI, DI 컨테이너
지금까지 구현한 DI프레임워크의 핵심 설계와 구현은 가능한 스프링 프레임워크의 설계와 구현을 따르기 위해 노력했다. DI 프레임워크를 구현하면서 스프링 프레임워크에 대한 이해도를 높이는 측면도 있지만 스프링 프레임워크가 객체지향 설계에 대해 바울 점이 많은 코드이기 때문이다.

지금까지 DI 프레임워크를 스프링 프레임워크 코드를 참고해 패키지를 분리하고, 인터페이스화하는 작업을 진행해보자.

## 12.8 웹 서버 도입을 통한 서비스 운영
- 톰캣 배포
- nginx 배포
- 빌드/배포 자동화