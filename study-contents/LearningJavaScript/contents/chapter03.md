## Chapter 3. 리터럴과 변수, 상수, 데이터 타입
### 1. 변수와 상수
- 변수
  ```javascript
  let currentTempC = 22  // 섭씨온도
  ```
  - 이름이 붙은 값으로, 값이 언제든지 바뀔 수 있다.
  - 변수를 선언할 때 초깃값을 할당하지 않으면 암시적으로 `undefined`가 할당된다.
- 상수
  ```javascript
  const ROOM_TEMP_C = 21.5, MAX_TEMP_C = 30
  ```
  - 변수와 마찬가지로 값을 할당받을 수 있지만, 한 번 할당한 값을 바꿀 수 없다.
  - 상수 이름은 보통 대문자와 밑줄만 사용한다.
  - ES6에서 새로 생겼다.

### 2. 식별자 이름
- 변수와 상수, 함수 이름을 식별자 라고 부른다. 그리고 식별자에는 규칙이 있다.
  - 식별자 규칙
    - 식별자는 반드시 글자라 달러 기호($), 밑줄(_)로 시작해야 한다.
    - 식별자에는 글자와 숫자, 달러 기호, 밑줄만 슬 수 있다.
    - 유티코드 문자도 쓸 수 있다.
    - 예약어는 식별자로 쓸 수 없다.
- 자바스크립트 식별자 표기법은 여러 가지이지만, 가장 널리 쓰는 두 가지는 다음과 같다.
  - 카멜 케이스(camel case)
    - `currentTempC`, `anIdentifierName`
    - 카멜이라는 이름은 중간중간의 대문자가 낙타의 혹처럼 보인다 해서 붙었다.
  - 스네이크 케이스(snake case)
    - `current_temp_c`, `an_identifier_name`
    - 카멜 케이스보다는 조금 덜 쓰인다.
- 식별자를 만들 때 고려사항
  - 식별자는 대문자로 시작해서는 안 된다. 예외는 클래스 뿐이다.
  - 밑줄 한 개 또는 두 개로 시작하는 식별자는 아주 특별한 상황, 또는 '내부'변수에서만 사용한다.
  - 제이쿼리를 사용할 경우, 달러 기호로 시작하는 식별자는 보통 제이쿼리 객체라는 의미다.

### 3. 리터럴
- 값을 프로그램 안에서 직접 지정한다는 의미이다.
- 리터럴과 식별자의 차이
  ```javascript
  let room1 = 'conference_room_a' // 'conference_room_a'(따옴표 안)은 리터럴
  let currentRoom = room1         // 이제 currentRoom의 값은 room1의 값(conference_room_a')과 같다.
  currentRoom = conference_room_a // 에러, conference_room_a 라는 식별자는 존재하지 않는다.
  ```
  - `room1` 은 변수를 가리키는 식별자이다.
  - `'conference_room_a'`은 문자열 리터럴인 동시에 `room1`의 값이다.
  - 자바스크립트는 따옴표를 통해 리터럴과 식별자를 구별한다.
  - 식별자는 숫자로 시작할 수 없으므로 숫자에는 따옴표가 없다.

### 4. 원시 타입과 객체
- 자바스크립트의 값은 *원시 값(primitive)* 또는 *객체(object)* 이다.
- 문자열과 숫자 같은 원시타입은 불변(immutable)이다.
- 원시 타입
  - 숫자
  - 문자열
  - 불리언
  - null
  - undefined
  - 심볼
- 객체
  - Array
  - Date
  - RegExp
  - Map, WeakMap
  - Set, WeakSet

### 5. 숫자
- 자바스크립트에는 숫자형 데이터 타입이 하나밖에 없다.
  - 대부분의 프로그래밍 언어는 여러 가지 정수 타입을 사용하며 부동소수점 숫자 타입도 두 가지 이상 사용한다.
  - 숫자형 데이터를 하나만 갖기로 한 선택은 자바스크립트를 단순한 언어로, 특히 초보자에게 부담 없는 언어로 만들어졌다는 장점이 있다.
  - 반면, 자바스크립트를 고성능 정수 연산이나 정밀한 소수점 연산이 필요한 애플리케이션에서 쓸 수 없다.
- 자바스크립트는 10진수, 2진수, 8진수, 16진수의 네 가지 숫자형 리터럴을 인식한다.
  - 10진수 리터럴에는 소수점 없는 정수, 소수점 있는 10진수, 과학에서 사용하는 지수 표기법을 쓸 수 있다.
  - 그 외에도 무한대, 음의 무한대, '숫자가 아님'을 나타내는 특별한 값들이 있다.
    - 엄밀히 말해 이들은 숫자형 리터럴이 아니지만, 숫자형 값이므로 포함했다.
  ```javascript
  let count = 10          // 숫자 리터럴, count는 더블이다.
  const blue = 0x000ff    // 16진수
  const umask = 0o0022    // 8진수
  const roomTemp = 21.5   // 10진수
  const c = 3.0e6         // 지수
  const inf = Infinity  
  const ninf = -Infinity
  const nan = NaN         // '숫자가 아님'
  ```
- 숫자에 대응하는 `Number` 객체에는 중요한 숫자형 값에 해당하는 유용한 프로퍼티가 있다.
  ```javascript
  const small = Number.EPSILON
  const bigInt = Number.MAX_SAFE_INTEGER
  const max = Number.MAX_VALUE
  const minInt = Number.MIN_SAFE_INTEGER
  const min = Number.MIN_VALUE
  const nInf = Number.NEGATIVE_INFINITY
  const nan = Number.NaN
  const inf = Number.POSITIVE_INFINITY
  ```

### 6. 문자열
- 문자열은 텍스트 데이터이다.
- 자바스크립트 문자열은 유니코드 텍스트이다.
  - 유니코드 텍스트는 데이터에 관한 표준이며 사람이 사용하는 언어 대부분의 글자와 심볼에 해당하는 코드 포인트를 포함하고 있다.
- 자바스크립트의 문자열 리터럴에는 작은따옴표, 큰따옴표, 백틱을 사용한다.
  - 백틱은 ES6에서 도입한 것이며 *템플릿 문자열*에서 사용한다.

### 7. 템플릿 문자열
- ES6 이전에는 변수나 상수를 문자열 안에 쓰는 방법은 문자열 병합뿐이었다.
- ES6에서는 문자열 템플릿이라는 기능을 도입했다.
- 문자열 템플릿은 문자열의 정해진 위치에 값을 채워넣는 간편한 방법이다.
- 큰따옴표나 작은따옴표를 쓰지 않고 백틱을 사용한다.
- 달러 기호 다음에 중괄호로 감싼 값을 쓰면 그 값이 문자열에 삽입된다.
```javascript
let currentTemp = 19.5
const message = `The current temperature is ${currentTemp}`
```

### 8. 불리언
- `true`와 `false` 두 가지 값밖에 없는 데이터 타입이다.
- 따옴표 안에 넣지 않도록 조심해야 한다.
  - 문자열 "false" 는 참 이다.

### 9. 심볼
- 유일한 토큰을 나타내기 위해 ES6에서 도입한 새 데이터 타입이다.
- 심볼은 항상 유일하며, 다른 어떤 심볼과도 일치하지 않는다.
- 심볼은 `Symbol()` 생성자로 만든다. 원한다면 생성자에 간단한 설명을 추가할 수 있다.
```javascript
const RED = Symbol('The color of a sunset!')
const ORANGE = Symbol('The color of a sunset!')
RED === ORANGE // false: 심볼은 모두 서로 다르다.
```

### 10. null과 undefined
- `null`이 가질 수 있는 값은 `null` 하나뿐이며, `undefined`가 가질 수 있는 값도 `undefined` 하나뿐이다.
- `null`과 `undefined`는 모두 존재하지 않는 것을 나타낸다.
- 일반적인 규칙으로는 `null`은 프로그래머에게 허용된 데이터 타입이고, `undefined`는 자바스크립트 자체에서 사용하는 데이터 타입이다.
- 프로그래머도 `undefined`값을 사용할 수는 있지만, 꼭 필요할 때만 사용하도록 주의해야 한다.
  - 변수에 직접 `undefined`를 할당하는 경우는, 아직 값이 주어지지 않은 변수의 동작을 고의로 흉내 내야 할 때 뿐이다.
  - 변수의 값을 아직 모르거나 적용할 수 없는 경우에는 대부분 `null`이 더 나은 선택이다.
- 변수를 선언하기만 하고 명시적으로 값을 할당하지 않으면 그 변수에는 기본적으로 `undefined`가 할당된다.

### 11. 객체
- 객체는 여러 가지 값이나 복잡한 값을 나타낼 수 있으며, 변할 수도 있다.
- 객체의 본질은 *컨테이너*이다.
  - 컨테이너의 내용물은 시간이 지나면서 바뀔 수 있지만, 내용물이 바뀐다고 컨테이너가 바뀌는 건 아니다.
  - 즉, 여전히 같은 객체이다.
- 객체는 중괄호({})를 사용하는 리터럴 문법이 있다.
- 객체의 콘텐츠는 *프로퍼티* 또는 *멤버*라고 부른다.
  - 프로퍼티는 이름(키)과 값으로 구성된다.
  - 프로퍼티 이름은 반드시 문자열 또는 심볼이어야 하며, 값은 어떤 타입이든 상관없고 다른 객체여도 괜찮다.
- 프로퍼티 이름에 유효한 식별자를 써야 *멤버 접근 연산자(.)* 를 사용할 수 있다.
- 프로퍼티 이름에 유효한 식별자가 아닌 이름을 쓴다면 *계산된 멤버 접근 연산자([])* 를 써야 한다.
  ```javascript
  const doy1 = {
    name: 'doy',
    age: 25,
  }

  const doy2 = { name: 'doy', age: 4 }

  const doy3 = {
    name: 'doy',
    classification: {
      kingdom: 'Anamalia',
      ~~~
    }
  }
  ```
- 객체에 함수를 담을 수도 있다.
  ```javascript
  doy3.speak = function() { return 'I am doy!' }
  ```
- 함수 뒤에 괄호를 붙여 함수를 호출할 수 있다.
  ```javascript
  doy3.speak() // 'I am doy!'
  ```
- 객체에서 프로퍼티를 제거할 때는 `delete` 연산자를 사용한다.
  ```javascript
  delete doy3.speak
  ```


### 12. Number, String, Boolean 객체
- 숫자와 문자열, 불리언에는 각각 대응하는 객체 타입 `Number`, `String`, `Boolean`이 있다.
- 이들 객체에는 두 가지 목적이 있다.
  - `Number.INFINITY` 같은 특별한 값을 저장하는 것
  - 함수 형태로 기능을 제공하는 것
    ```javascript
    const s = 'hello'
    s.toUpperCasE()
    ```
    - `s`는 마치 객체처럼, 즉 함수 프로퍼티를 가진 것처럼 보인다.
    - 하지만 `s`는 원시 문자열 타입이다.
    - 자바스크립트는 *일시적인 `String` 객체*를 만든다. 이 임시 객체에 `toUpperCase` 함수가 들어있다.
    - 자바스크립트는 함수를 호출하는 즉시 임시 객체를 파괴한다.

### 13. 배열
- 일반적인 객체와 달리 배열 콘텐츠에는 항상 순서가 있고, 키는 순차적인 숫자이다.
- 배열은 유용한 메서드를 많이 가진 대단히 강력한 데이터 타입이다.
- 다음과 같은 특징이 있다.
  - 배열 크기는 고정되지 않는다. 언제든 요소를 추가하거나 제거할 수 있다.
  - 요소의 데이터 타입을 가리지 않는다. 즉, 문자열만 쓸 수 있는 배열이라던가 숫자만 쓸 수 있는 배열 같은 개념이 없다.
  - 배열 요소는 0으로 시작한다.
- 자바스크립트의 배열 리터럴은 다음과 같이 대괄호 안에 배열 요소를 쉼표로 구분해서 쓴다.
```javascript
const a1 = [1, 2, 3, 4]         // 숫자로 구성된 배열
const a2 = [1, 'two', 3, null]  // 여러 가지 타입으로 구성된 배열
const a3 = [                    // 객체가 들어있는 배열
  { name: 'doy', age: 25},
  { name: 'hee', age: 26},
  { name: 'delf', age: 28},
  { name: 'nesoy', age: 28},
]
const a4 = [                    // 배열이 들어있는 배열
  [1, 3, 5],
  [2, 4, 6],
]
```

### 14. 객체와 배열 마지막의 쉼표
- 자바스크립트 문법에서는 객체와 배열 요소를 여러 행에 나눠 썼을 때 마지막 쉼표를 계속 허용했다.
- 배열과 객체에서 잘라내고 붙여넣는 일이 많고, 객체 마지막에 프로퍼티를 추가하는 일이 많으므로 마지막 쉼표를 사용하는 것을 권장한다.

### 15. 날짜
- 자바스크립트의 날짜와 시간은 내장된 `Date` 객체에서 담당한다.
- `Date` 객체는 사용하기 어려운 편이고, 특히 타임존이 다른 날짜를 다룰 때는 매우 어렵다.
- 현재 날짜와 시간을 나타내는 개체를 만들 때는 `new Date()`를 사용한다.
- 특정 날짜에 해당하는 객체를 만들 때는 다음과 같이 한다.
  ```javascript
  const halloween = new Date(2018, 9, 31) // 월은 0에서 시작, 즉 9는 10월
  ```
- 특정 날짜와 시간에 해당하는 객체를 만들 때는 다음과 같이 한다.
  ```javascript
  const halloween = new Date(2018, 9, 31, 19, 0) // 19:00 = 7:00 pm
  ```

### 16. 정규표현식
- 자바스크립트의 정규 표현식은 `RegExp` 객체를 사용한다.
- 슬래시 한 쌍 사이에 심볼을 넣는 리터럴 문법도 있다.
  ```javascript
  const email = /\b[a-z0-9._-]+@[a-z_-]+(?:\.[a-z]+)+\b/
  ```

### 17. 맵과 셋
- ES6에서 새로운 데이터 타입 `Map`과 `Set`, 그리고 그들의 '약한' 짝인 `WeakMap`과 `WeakSet`을 도입했다.
- `Map`은 객체와 마찬가지로 키와 값을 연결하지만, 특정 상황에서 객체보다 유리한 부분이 있다.
- `Set`은 배열과 비슷하지만 중복이 허용되지 않는다.
- `WeakMap`과 `WeakSet`은 `Map`과 `Set`과 마찬가지로 동작하지만, 특정 상황에서 성능이 더 높아지도록 일부 기능을 제거한 버전이다.

### 18. 데이터 타입 변환
#### 1. 숫자로 변환
방법1. `Number` 객체 생성자 사용
  ```javascript
  const numStr = '33.3'
  const num = Number(numStr)
  ```
  - 숫자로 바꿀 수 없는 문자열에서는 `NaN`이 반환된다.

방법2. 내장 함수인 `parseInt`나 `parseFloat` 함수 사용
  ```javascript
  const a = parseInt('16 volts', 10) // ' volts'는 무시된다. 10진수 16
  const b = parseInt('3a', 16)       // 16진수 3a를 10진수로 바꾼다.
  ```
  - 기수를 넘길 수 있다.
  - 숫자로 판단할 수 있는 부분까지만 변환하고, 그 뒤에 있는 문자열은 무시한다.
#### 2. 문자열로 변환
- 자바스크립트의 모든 객체에는 문자열 표현을 반환하는 `toString()` 메서드가 있다.
- 배열의 `toString()` 메서드는 각 요소를 문자열로 바꾼 다음 쉼표로 연결한 문자열을 반환한다.
  ```javascript
  const arr = [1, true, 'hello']
  arr.toString()  // '1,true,hello'
  ```
#### 3. 불리언으로 변환
- 부정 연산자(!)를 써서 모든 값을 불리언으로 바꿀 수 있다.
- 부정 연산자를 한 번 사용하면 '참 같은 값'은 `false`로 바뀐다.
- 부정 연산자를 한 번 더 쓰면 `true`를 얻을 수 잇다.
- 숫자형 변환과 마찬가지로 `Boolean` 생성자를 써도 결과는 같다.
```javascript
const n = 0             // 거짓 같은 값
const b1 = !!n          // false
const b2 = Boolean(n)   // false
```
