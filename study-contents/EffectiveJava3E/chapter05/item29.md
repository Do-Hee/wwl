# [item 29] 이왕이면 제네릭 타입으로 만들라

### 사전 조사
### 일반 클래스를 제네릭 클래스로 만드는 방법
1. 클래스 선언에 타입 매개변수를 추가
    - 타입 이름으로 보통 `E`를 사용한다.
2. 일반 타입(ex. `Object`)를 타입 매개변수로 교체
3. 비검사(unchecked) 경고 해결하기

### 실체화 불가 타입으로 배열을 만드려 할 때
- `new E[]`는 실체화 불가 타입이므로 배열로 만들 수 없다.
- 이를 해결하기 위해 아래와 같은 두 가지 방법이 있다.
  1. `Object` 배열을 생성한 다음 제네릭 배열로 형변환한다.
      - 이 방법은 경고를 발생 시키므로 안전함이 증명되었다면 `@SuppressWarning` 애너테이션으로 경고를 숨긴다.
      - 형변환을 배열 생성 시 단 한 번만 하면 된다.
      - 단, 힙 오염을 발생시킬 수 있다.
  2. `E[]`에서 `Object[]`로 변경한다.
      - 배열에서 원소를 읽을 때마다 형변환을 해야한다.

### 항상 배열보다는 리스트를 우선하는 것이 좋을까?
- 항상 가능하지도 않으면 더 좋지도 않다.
  - `ArrayList` 같은 제네릭 타입도 결국은 기본 타입인 배열을 사용해 구현해야 한다.
  - `HashMap` 같은 제네릭 타입은 성능을 높일 목적으로 배열을 사용하기도 한다.
- 기본 타입은 제네릭 타입으로 쓸 수 없다. (ex. `List<int>`)
  - 이럴 땐 박싱된 기본타입으로 쓰면 된다.

### 타입 매개변수에 제약을 두는 제네릭
- `DelayQueue`
  - `class DelayQueue<E extends Delayed> implements BlockingQueue<E>`
  - `DelayQueue`의 원소에서 형변환 없이 곧바로 `Delayed` 클래스의 메서드를 호출할 수 있다.
  - 이러한 타입 매개변수 `E`를 **한정적 타입 매개변수**라 한다.

### 결론
  - 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하니 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 구현하자.
  - 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경하자.

## Reference


### 스터디 요약
-
---

> :leftwards_arrow_with_hook:[EffectiveJava3E](/EffectiveJava3E/README.md)

