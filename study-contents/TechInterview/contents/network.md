# 2. Network
## 📖 Contents
- OSI 7계층
- TCP/IP의 개념
- TCP와 UDP
- TCP와 UDP의 헤더 분석
- TCP의 3-way-handshake와 4-way-handshake
    - Q. TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?
    - Q. 만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 - 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?
    - Q. 초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?
- HTTP와 HTTPS
- HTTP 요청/응답 헤더
- CORS란
- GET 메서드와 POST 메서드
- 쿠키(Cookie)와 세션(Session)
- DNS
- REST와 RESTful의 개념
- 소켓(Socket)이란
- Socket.io와 WebSocket의 차이
- Frame, Packet, Segment, Datagram

---
## HTTP와 HTTPS
### HTTPS?
- Hypertext Transfer Protocol **Over Secure Socket Layer**의 약자로, 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer)프로토콜을 이용하여 클라이언트(주로 웹브라우저)와 서버가 데이터를 주고 받는 통신 규약

### HTTP와 차이점
- 보안이 강화된 HTTP
- HTTPS는 HTTP의 하부에 SSL과 같은 보안계층을 제공함으로써 동작
- 80번이 아닌 443번 포트를 사용
- 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화됨

![](./resources/http_https.png)

### 원리
- 암호화, 복호화시킬 수 있는 서로 다른 키 2개가 존재
    - 이 두 개의 키는 서로 1번 키로 암호화하면 반드시 2번키로만 복호화할 수 있고 2번 키로 암호화하면 반드시 1번키로만 복호화할 수 있음
- 그 중에서 하나 키는 모두에게 공개하는 공개키(1번 키)로 만들어서 공개키 저장소에 등록
- 서버는 서버만 알 수 있는 개인키(2번 키)를 소유
- 1번키로 암호화된 HTTP 요청, 즉 HTTPS 프로토콜을 사용한 요청이 온다면 서버는 개인키(2번 키)를 이용하여 1번키로 암호화된 문장을 해독
- 서버는 요청이 무엇인지 알게되고 요청에 맞는 응답을 다시 개인키(2번 키)로 암호화해서 요청한 클라이언트에게 송신
- 응답을 받은 클라이언트는 공개키(1번 키)를 이용해서 개인키(2번 키) 암호화된 HTTPS 응답을 해독하고 사용


### 통신 방법
1. 먼저 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해서 공개키와 개인키를 만듬
2. 그 다음에 신뢰할 수 있는 CA 기업을 선택하고 그 기업에 내 공개키를 관리해달라고 계약하고 돈을 지불
3. 계약을 완료한 CA 기업은 또 CA 기업만의 공개키와 개인키가 존재
CA 기업은 CA기업의 이름과 A서버의 공개키, 공개키의 암호화 방법 등의 정보를 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공
4. A서버는 암호화된 인증서를 갖게 되었습니다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청(Request)이 오면 이 암호화된 인증서를 클라이언트에게 제공
5. 클라이언트가 A서버에게 index.html 파일을 달라고 요청하면, HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 수신
6. 이때 브라우저는 CA 기업이 제공하는 대부분의 공개키는 알고있음
7. 해당 인증서를 해독하여 A서버의 공개키를 획득
8. 그러면 A서버와 통신할 때는 A서버의 공개키로 암호화해서 통신

### SSL (Secure Socket Layer)
- HTTPS에서 보안을 위해 사용되는 프로토콜
  - 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS(Transport Layer Security Protocol)라는 이름으로 바뀌었다
  - TLS 1.0은 SSL 3.0을 계승했지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용된다
- Certificate Authority(CA)라 불리는 서드 파티로부터 서버와 클라이언트의 인증을 하는데 사용

### SSL 인증서
- SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서
- 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달하게 된다
- 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한다

#### SSL 동작방법
- 공개키 암호 방식은 알고리즘 계산방식이 느린 경향이 있다
- 따라서 SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키 암호화 방식을 혼합하여 사용한다
- 안전한 의사소통 채널을 수립할 때는 공개키 암호를 사용하고, 이렇게 만들어진 안전한 채널을 통해서 임시의 무작위 대칭키를 생성 및 교환한다. 해당 대칭키는 나머지 데이터 암호화에 활용한다

### Reference
- [[첫 발] [WAS]Tomcat SSL 적용](https://shxrecord.tistory.com/168)
- [[기본기를 쌓는 정아마추어 코딩블로그] Http와 Https 이해와 차이점 그리고 오해(?)](https://jeong-pro.tistory.com/89)
- [SSL(Secure Socket Layer) 이란](https://12bme.tistory.com/80)
- [[초보몽키의 개발공부로그] HTTPS와 SSL 인증서, SSL 동작방법](https://wayhome25.github.io/cs/2018/03/11/ssl-https/)