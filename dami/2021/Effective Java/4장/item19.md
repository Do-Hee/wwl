# 아이템19 - 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

## 상속을 고려한 설계와 문서화란?
1. 메소드를 재정의하면 **어떤 동작**을 하는지 정확히 정리 필요
    - 상속용 클래스는 재정의할 수 있는 메소드들을 내부적으로 어떻게 이용하는지 문서화
    - 좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지 설명해야 한다는 말도 있지만, 클래스의 안전한 상속을 위해서는 내부 구현 방식을 설명하는 상황도 필요함
    - 재정의 가능 여부, 메소드 호출 순서, 메소드 호출 이후 수행할 작업에 미치는 영향 등 **재정의 가능 메소드를 호출할 수 있는 모든 상황**에 대해 작성
    - 메소드 주석에 `@implSpec` 작성 시 자바독 도구가 `Implementation Requirements` 항목이 자동 생성되며 여기 작성하면 됨
      - 현재 `@implSpec` 태그는 자바독 선택사항이며, 활성화하려면 명령줄 매개변수에 다음 내용 추가
        - `-tag "implSpec:a:Implementatoin Requirements:"`
2. **효율적인 하위 클래스**를 위해서라면, 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 `protected` 메소드로 공개해야 할 가능성 보유
    - 예를 들어 `AbstractList`의 `removeRange(int fromIndex, int toIndex)` 메소드가 훅으로 선별되어 `protected` 메소드
    - 이 리스트 혹은 이 리스트의 부분리스트에 정의된 `clear` 연산이 이 메소드를 호출
    - 하위 클래스에서 부분리스트의 `clear` 메소드 성능을 높이기 위함
3. 상속용 클래스를 쓸만한지 테스트하는 방법은 직접 하위 클래스를 만들어보는 것
4. 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증
5. 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능한 메소드 호출 금지
    - `private`, `static`, `final`은 재정의 불가능하니 사용 가능


### 후기
AbstractListd의 removeRange 내부 구현 함 찾아보는 것도 좋을듯
