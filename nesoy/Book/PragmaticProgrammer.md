# 실용주의 프로그래머
#### 자신의 기술에 관심과 애정을 가져라.
#### 자신의 일에 대해 생각하면서 일하라.
#### 어설픈 변명을 만들지 말고 대안을 제시하라.
#### 깨진 창문을 내버려두지 말자.
- 발견하자마자 바로 고쳐라.
#### 변화의 촉매가 되라
- 허락을 얻는 것보다 용서를 구하는 것이 쉽다.
#### 큰 그림을 기억하라.
#### 품질을 요구사항으로 만들어라.
- 자신이 한 것을 비판적인 눈으로 보기 위해 늘 뒤로 물러서서 보자.
- 완벽해지기란 불가능하다.
#### 지식 포트폴리오에 주기적으로 투자하라.
- 주기적으로 노력하는 습관
- 다양한 분야에 투자할 것.
- 보수적인 투자. 위험성이 큰 투자. 보상이 높은 사이에서 균형을 잘 맞춘다.
- 주기적으로 재검토하고 재조정해야 한다.
- 목표
    - 매년 새로운 언어를 최소 하나를 배우기.
    - 기술 서적을 분기마다 한 권씩 읽기.
    - 비 기술 서적도 읽기
    - 수업을 듣거나 지역 사용자 모임에 참여하기
    - 다른 환경에서 실험해보기.
    - 흐름을 놓치지 말기.
#### 읽고 듣는 것을 비판적으로 분석하라.
- 읽거나 듣는 것에 대해 비판적으로 생각하는 것.
- 누군가 좋은 자리를 차지하려고 돈을 지불했을 수 있다.
#### 무엇을 말하는가와 어떻게 말하는가 모두 중요하다.
- WISDOM
    - What - 무엇을 배우길 원하는가?
    - Interest - 말하려는 것에서 그들이 관심 있어 하는 건 무엇인가?
    - Sophisticated - 얼마나 소양이 있는가?
    - Detail - 어느 정도의 구체적인 내용을 원하는가?
    - Owe - 누가 정보를 소유하길 원하는가?
    - Motivate - 그들이 경청하도록 동기를 주려면 어떻게 해야 할까?

#### DRY - Don't Repeat Yourself
- 낮은 차원의 지식은 그것이 속하는 코드에 두고 주석은 다른 높은 차원의 설명을 위해 아껴두자.
- 돌아가는 길이 지름길이다.
    - 지금 당장 몇 초를 절약할 수 있을지라도, 나중에는 몇 시간을 잃게 될런지 모른다.

#### 재사용하기 쉽게 만들라.
- 재사용이 쉽지 않다면 사람들은 사용하지 않을 것이다. 실패한다면 지식 중복의 위험을 각오해야 한다.

#### 관련 없는 것들 간에 서로 영향이 없도록 하라.
- 직교적인 시스템을 만들자.
- 변화가 Localize되서 개발 시간과 테스트 시간이 줄어든다.
- 감연된 코드는 격리된다.
- 시스템이 잘 깨어지지 않는다.
- 코드의 결합도를 줄여라
    - Write Shy Code
    - Law of Demeter
- 전역 데이터를 피하라.
    - 싱글톤 객체를 전역 데이터의 일종으로 사용하지 말자. 불필요한 링크를 제거하자.
- 유사한 함수를 피하라.
- 항상 자신이 작성하는 코드를 항상 비판적으로 검토해 보는 습관을 기르자.


#### 최종 결정이란 없다.
> 당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다.
- 여러분의 코드는 몇 가지 가능한 미래를 지원할 수 있는가?
- 어떤 미래가 일어날 가능성이 높을까? 그 미래가 닥쳤을 때, 이를 지원하는 것이 얼마나 어려울까?


#### 목표물을 찾기 위해 예광탄을 써라
- 예광탄 코드는 나중에 버리려고 만드는 것이 아니다.
    - 재사용한다. 완전한 기능이 들어있지 않을 뿐.
    - 필요하다면 조정도 할 수 있다.
- 프로토타이핑
    - 위험을 수반하는 모든 것이다.

#### 프로토타입을 통해 학습하라
- 무시해도 좋은 세부사항
    - 정확성
    - 완전성
    - 안정성
    - 스타일
- 빠르게 만들고 잠재적 문제 지점을 발견하자.


#### 문제 도메인에 가깝게 프로그래밍하라.
- 더 높은 추상화 수준에서 작업함으로써 사소한 구현의 세부사항들을 무시하고 도메인의 문제들을 푸는 일에만 정신을 집중할 수 있다.


#### 추정을 통해 놀람을 피하라
- 얼마나 정확한 것이 충분히 정확한 것인가?
    - 자신에게 물어봐야 할 첫 번째 질문은 여러분의 답변이 사용될 상황이다.
- 이미 그 일을 해본 사람에게 물어보라는 것이다.
- 그들이 어떻게 문제를 해결했는지 이해하려 노력해보자.
- 상대방이 무엇을 묻고 있는지에 대해 이해하는 것.
- 추정을 하기 전에 미리 생각하는 습관을 기르는 것이 좋다.
- 추정치를 잘못되었더라도 움츠리거나 도망가지 마라. 왜 여러분의 추측과 실제 값이 달라졌는지 원인을 찾아야 한다. 시간을 들여 이를 규명하라. More better than yesterday

#### 코드와 함께 일정도 반복하며 조정하라

#### 지식을 일반 텍스트로 저장하라
- 유닉스 철학
    - 작고 예리한 각각의 도구가 한 가지 일만 잘 하도록 만들자는 철학

#### 명령어 셸의 힘을 사용하라
- 셸 명령은 이해하기 어렵거나 너무 불친절해 보일런지도 모르겠지만, 이것들은 강력하고 간결하다.

#### 하나의 에디터를 잘 사용하라
- 모든 기능을 사용해보자.

#### 언제나 소스코드 관리 시스템을 사용하라.
- 진보라는 것은 변화와는 걸리가 멀고 오히려 기억에 의존한다. 과거를 기억하지 못하는 사람은 과거를 반복할 운명이다.


#### 비난 대신 문제를 해결하라
- 버그가 여러분의 잘못인지 다른 사람의 잘못인지는 그리 중요한 게 아니다. 버그를 해결하는게 중요하다.

#### 디버깅을 할 때 당황하지 마라.
- 가장 속이기 쉬운 사람은 자기 자신이다.
- 표면에 보이는 증상만 고치려는 욕구에 저항하라. 실제 문제는 여러분이 관찰하고 있는 것에서 몇 단계 떨어져 있고, 또 다른 여러 가지와 연관되어 있을 확률이 다분하다.
- 항상 문제의 근본적인 원인을 발견하려고 노력하고, 그 문제의 특정한 증상만 고치려고 하지 말라.
- 버그상황을 재현하도록 노력하자.
- 데이터를 가시화하라
- Tracing
- 고무오리 : 누군가에게 문제를 설명하게 되면 혼자 코드를 살펴 볼 때는 당연히 여기고 지나갈 것을 명시적으로 이야기함으로써 깨달음을 얻게 된다.

#### Select는 망가지지 않았다.
- 발굽 모양을 보면 말부터 생각해야지, 얼룩말부터 생각하지는 말자
- OS는 아마 망가지지 않았을 것이며, Database 또한 괜찮을 것이다.

#### 가정하지 마라. 증명하라
- 왜 이 실패가 더 일찍 발견되지 않았을까 생각해볼 필요가 있다.
- 버그를 미리 잡을 수 있도록 단위 테스트나 다른 테스트를 수정할 필요가 있다.
- 누군가가 잘못 내린 가정의 결과라면 다 같이 토론하라.

#### 텍스트 처리 언어를 하나 익혀라
#### 코드를 작성하는 코드를 작성하라
#### 완벽한 소프트웨어는 만들 수 없다.
- 자기 자신 역시 믿지 않는다.
- 완벽한 코드를 작성할 수 없음을 깨닫고 자신의 실수를 대비해 방어적으로 코드를 짠다.

#### 계약에 따른 설계를 하라.
- 컴퓨터 시스템을 다루는 것은 어렵다. 그러나 사람 문제는 더 어렵다.
- Lazy Code : 자신이 수용할 것에 대해서는 엄겨가게 하고, 내어줄 것에 대해서는 최소한도를 약속하는 것.

#### 일찍 작동을 멈추게 하라.
- 그런 일은 절대 일어날 리 없어라는 사고에 빠지기 쉽다.
- 실용주의 프로그래머는 만약 에러가 있다면 정말로 뭔가 나쁜 일이 생긴 것이라고 자신에게 이야기한다.

#### 단정문을 사용해서 불가능한 상황을 예방하라
- 물론 그건 절대 일어나지 않을 거야. 라는 생각이 든다면, 그걸 확인하는 코드를 추가하라.

#### 예외는 예외적인 문제에 사용하라.
- 예외를 정상적인 처리 과정의 일부로 사용하는 프로그램은 고전적인 스파게티 코드의 가독성 문제와 관리성 문제를 전부 떠안게 된다.
- 이런 프로그램은 캡슐화 역시 깨트린다. 예외 처리를 통해 루틴과 그 호출자들 사이의 결합도가 높아져 버린다.

#### 시작한 것은 끝내라.
- 코딩할 때 우리는 모두 리소스를 관리한다.
- 메모리, 트랜잭션, 쓰레드, 파일, 타이머 등 사용에 어떤 제한이 있는 모든 종류의 것. 할당하고, 사용하고, 해제한다.

#### 모듈간의 결합도를 최소화하라.
- Shy 코드를 작성하는 것은 이롭다.
- 남에게 속속들이 드러내지 말고, 너무 많은 사람과 상호작용하지 말라는 두 가지 의미를 모두 내포한다.
- 프로그램에서 모듈간 결합도를 최소화하려 시도한다.
- 객체가 제공하는 메서드에 접근하기 위해 또 다른 객체들을 통하는 것을 허용하지 않는다.


#### 통합하지 말고 설정하라 - MetaProgramming
- 시스템을 되도록 설정가능하게 만들기 바란다.


#### 코드에는 추상화를 메타데이터에는 세부 내용을
- 설계의 겹합도를 줄여 좀 더 유연하고 적응성 있는 프로그램을 만들 수 있다.
- 세부사항을 코드 밖으로 몰아냄으로써 보다 강하고 추상적인 디자인을 만들 수 있다.
- 커스터마이징하기 위해 다시 컴파일할 필요가 없다.
- 가능한 마지막 순간까지 세부 정의를 피하고, 세부사항을 소프트하게, 변화하기 쉽게 남겨 두라. 빠르게 변화할 수 있는 해결안을 강구함으로써 유연한 소프트웨어를 만들 수 있다.


#### 작업흐름 분석을 통해 동시성을 개선하라.
- 우리는 동시성을 허용할 필요가 있고 시간이나 순서에 따른 의존성의 결합을 끊는 방법을 생각할 필요가 있다.
- 그렇게 함으로써 유연성도 얻을 수 있고, 작업흐름 분석, 아키텍처, 설계, 배치와 같은 개발의 여러 측면에서 시간과 관련된 모든 의존성도 줄일 수 있다.


#### 서비스를 사용해서 설계하라
- Hungry Consumer Model
- Message Queue를 활용하여 서로 시간적으로 결합이 끊기는 것이다.

#### 언제나 동시성을 고려해 설계하라.
- Thread-Safe한 상태를 유지하라.
- 동시성 요소가 포함된 아키텍처를 설계한 다음에는 수많은 동시적 서비스들을 다루는 것에 대해 생각하기도 더 쉬워진다.
- 클라이언트-서버로 할지, n-티어로 할지 결정하는 문제에 대해서도 유연하게 대응할 수 있다.

#### Model에서 View를 분리하라.
- Observer Pattern
- Publish / Subscribe Pattern - Event
- MVC - Model View Controller
- MVP - Model View Presenter


#### 칠판을 사용해 작업흐름을 조율하라.
- 칠판 : 비동기적으로 데이터를 주고받는 공간
- 칠판 정리하기 : 관심사를 모아서 따로 zone를 만들거나 group을 사용하기도 한다.

> 코딩도 똑같다. 대부분은 반복적인 일이지만, 마음을 늘 깨어있도록 유지하면 재앙을 막을 수 있다.

#### 우연에 맡기는 프로그래밍을 하지 말라.
- 정말로 제대로 돌아가는 것이 아닐지도 모른다. 우리에게만 그런 것처럼 보일 수도 있다.
- 불필요한 추가 호출은 코드를 더 느리게 만든다.
- 언제나 자기가 지금 무엇을 하고 있는지 알아야 한다.
- 맹목적으로 코딩하지 말라. 익숙하지 않은 기술을 사용하려고 시동하는 행동은 우연에게 자기를 유혹해도 좋다는 초청장을 보내는 것과 다름없다.
- 계획을 세우고 그것을 바탕으로 진행하라. 머리 속에 있는 계획이든, 어떤 계획이든
- 신뢰할 수 있는 것에만 기대라. 우연한 일이나 가정에 의존하지 말라.
- 여러분의 가정을 문서로 남겨라. 자신의 마음속에서 가정을 명확하게 하는 데에도 도움이 된다.
- 코드만 테스트할 것이 아니라 여러분이 세운 가정도 테스트해 보아야 한다.
- 노력을 기울일 대상의 우선순위를 정하라. 중요한 것들에 먼저 시간을 투자하라. 중요한 부분이 가장 어려운 부분이기도 한 경우가 많다.
- 과거의 노예가 되지 말라. 더 이상 적절한 코드가 아니라고 생각되면, 어떤 코드라도 교체할 수 있어야 한다.


#### 알고리즘을 추정한다는 말의 의미는 무엇인가?
- Big O notation
    - 프로그램에 레코드 천 개를 주면 시간이 얼마나 걸리는 지 안다.
    - 하지만 백만 개라면 어떨까?
    - 근사값을 기록하는 방식을 이용하면 답을 찾을 수 있다.
- 일반적으로 입력의 크기는 알고리즘에 영향을 준다.
- 입력이 크기가 클수록, 알고리즘의 수행시간이 길어지거나 사용하는 메모리 양이 늘어난다.
- 이런 관계가 늘 1차 함수처럼 선형적이라면 알고리즘은 필요가 없었을 것이다.
- 알고리즘은 대게 선형적이지 않다.
- 선형보다 훨씬 심각한 경우도 있다는 것이다. 즉 공간복잡도, 시간복잡도가 n보다 훨씬 빠르게 늘어난다.
- 주어진 환경에서 우리가 무리한 일을 하는 것은 아닌지 재빨리 확인해 보는 것에 가깝다.

#### O() 표기법
- 근사값을 다루기 위한 수학적 방법
- n이 커질수록 가장 큰 차수에 비하면 다른 차수는 무시해도 될 정도이기 때문에 관습적으로 최상위 차수를 제외한 다른 모든 차수는 제거하며 상수 곱수도 표시하지 안흔다.

#### 상식적인 추정
- 간단한 반복문
    - 1부터 n까지 돌아간다면 이 알고리즘은 O(n)일 가능성이 높다.
    - Example : 소진 정렬(Exhaustive Search), 배열에서 최대값 찾기, 체크섬값 생성하기
- 겹친 반복문
    - O(n^2)
    - Example : Bubble Sort
- 반씩 잘라 나가기
    - 반복문을 돌 때마다 작업 대상의 수를 반으로 줄여 나가는 알고리즘
    - O(logN)이 될 가능성이 높다.
    - Example
        - 이진 검색
        - 이진 트리의 순회
        - 기계 워드(Machine word)에서 첫째 세트 비트를 찾는 문제
- 나눠서 정복하기(Divide and conquer)
    - 입력 데이터를 각 반쪽에서 독립적으로 작업한 다음, 결과를 합치는 알고리즘
    - O(nlogN)이 될 수 있다.
    - 퀵 정렬이 전형적인 예
- 조합적(combinatoric)
    - 순열에는 factorial이 관련되기 때문이다.
    - 숫자 집합을 분할해서 각 부분 집합의 원소들의 합이 모두 같도록 만드는 문제

#### 여러분 알고리즘의 차수를 추정하라.
- 잠시 작업을 멈추고 커다란 수가 들어왔을 경우, 수행시간이나 메모리 소비에 어떤 영향을 미칠지 생각해보는 것이 좋다.
- O(n^2) 알고리즘이 있다면, O(nlogN)으로 줄이기 위해 나누어 정복하는 방법을 찾을 수 있는지 시도해본다.
- 메모리를 얼마나 사용할지 확실하지 않다면, 입력 레코드의 수나 혹은 런타임에 영향을 줄 것이라고 생각되는 어떤 요소든 바꾸어 가면서 직접 실행해보라.
- 그런 그래프를 그려보고 기울기가 작아지는지, 커브인가, 직선인지 대략적인 답이 나올 것이다.
- 단순한 O(n^2) 코드가 복잡한 O(nlogN) 코드보다 더 좋은 성능을 내기도 한다.
    - O(nlogN) 알고리즘에 무거운 내부 반복문이 들어있는 경우라면 특히 더 그러하다.
- 규모가 작을 때는 수행시간이 선형적으로 증가하다가도, 수백만 개의 레코드를 입력하면 시스템이 버벅이기 시작하면서 수행시간이 길어진다.
- 임의로 생성한 입력 키들로 정렬 루틴을 테스트하곤 했다면, 이미 정렬된 입력을 넣는 순간 놀라게 되는 일이 생길지도 모른다.
- 실용주의 프로그래머는 이론적 기반과 실무적 기반을 모두 고려하려고 노력한다.
    - 추정을 이미 했다고 하더라도, 현장에서 실제 데이터를 입력받아 돌아가는 코드의 수행시간만이 정말로 의미있는 수치이다.

#### 여러분의 추정을 테스트하라.
- 정렬 알고리즘을 수행하다가 너무 큰 정렬을 진행하여 Swapping이 시작되었고 수행시간 또한 극적으로 길어져버렸다.
- 최고라고 언제나 최고는 아니다.
    - 적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있다.
    - 입력값의 규모가 작다면 단순한 삽입 정렬도 퀵정렬과 비슷한 성능을 내준다.
    - 그러나 삽입 정렬을 작성하거나 디버깅하는데 걸리는 시간 < 퀵 정렬 작성 및 디버깅 시간
    - 요구하는 형식으로 준비하는데 비용이 많이 드는 것은 아닌지 주의 깊게 보아야 한다.

> 성급한 최적화를 조심하라. 어떤 알고리즘을 개선하느라 여러분의 귀중한 시간을 투자하기 전에 그 알고리즘이 정말로 병목인지 먼저 확실히 해두는 것은 언제나 좋은 생각이다.


#### 일찍 리팩터링하고, 자주 리팩터링하라.
- 코드는 정적인 존재가 아니다.
- 리팩터링은 언제 해야 하는가?
    - 중복
    - 직교성이 좋지 않은 설계
    - 유효기간이 끝난 지식
    - 성능
- 리팩터링해야 할 것들의 명단을 만들고 유지하라.
- 리팩터링의 본질은 재설계다. 언제라도 재설계의 대상이 될 수 있다.
- <https://nesoy.github.io/articles/2018-05/Refactoring>

#### 테스트를 염두에 두고 설계하라.
- 단위 테스트 : 어떤 모듈에게 이것저것을 시켜보는 코드를 가리킨다.
- 계약을 잘 지키는지 테스트 하는 것을 강조함으로써, 우리는 프로젝트 후반부에 벌어질 수 있는 이런 종류의 재앙들을 피하기 위한 노력을 할 수 있다.
- 에러가 나지 않게 하는 것보다 에러를 고치는데 더 좋은 방법은 없다.
- 테스트 집합이 아무리 좋더라도 모든 버그를 발견할 가능성은 없다.
- 여러분들이 테스트하지 않으면 결과적으로 사용자들이 테스트하게 된다.


#### 자신이 이해하지 못하는, 마법사가 만들어 준 코드는 사용하지 말라.
- 마법사가 만들어 준 코드를 모두 이해하지 못했다면, 여러분은 자기 어플리케이션의 주인이 아니다.
- 평범한 개발자가 자동으로 동등한 수준의 전문가가 되지는 않는다.
- 유지보수도 하지 못할 것이고, 디버깅해야 할 때가 오면 고생하게 될 것이다.

#### 요구사항을 수집하지 말고 채굴하라.
- 요구사항이 지면에 놓여져 있는 경우는 드물다. 보통은 가정과 오해속에 숨어 깊게 묻혀져 있다.
- 요구사항은 최대한 일반적 진술로 만들어야 한다.
    - 인사과에서만 직원기록을 열람할 수 있다.
    - 나중에 권한이 부여된 사용자만이 직원 기록에 접근할 수 있다.로 요구사항이 바뀐다면
    - 다시 시스템을 설계해야하고 수정해야 할 것이다.
- 메타데이터를 지원하도록 잘 분리된 시스템으로 구현하는 것이 좋다.
- 사용자의 요구사항 내면 깊이 들어갈 수 있는 단순한 기법
    - 직접 사용자가 되어 보는 것이다.
- 메타데이터를 지원하도록 잘 분리된 시스템으로 구현하는 것이 좋다.

#### 사용자처럼 생각하기 위해 사용자와 함께 일하라
- 사용자의 요구사항 내면 깊이 들어갈 수 있는 단순한 기법
    - 직접 사용자가 되어 보는 것이다.
- 요구사항은 아키텍처가 아니다. 요구사항은 설계가 아니며, 사용자 인터페이스도 아니다. 요구사항은 필요다.

#### 구체적인 것보다 추상적인 것이 더 오래간다.
- 클래스의 진정한 요구사항은 찾고 문제 해결을 하자.

#### 프로젝트 용어사전을 사용하라.
- 모든 사람이 일관성을 위해 동일한 용어 사전을 사용해야 한다.
- 여러 사람이 접근하기 쉬워야 한다.
- 웹 기반 문서를 사용하는 것은 좋은 방법이다.

#### 생각의 틀을 벗어나지 말고, 틀을 찾아라.
- 틀을 벗어나고 벗어나지 않고의 문제가 아니다.
- 문제는 틀을 찾는 것, 곧 정말로 제약인 것들을 찾는 일이다.
- 모든 가능한 해결 경로를 눈앞에 나열해보라. 아무리 쓸모없고 바보같이 보이는 경로라도 절대 버리지 말라.
- 바보같은 것을 확신하는가? 증명할 수 있는가?

#### 스스로에게 물어보자.
- 더 쉬운 방법이 존재하는가?
- 진짜 문제를 풀려고 노력하고 있나. 그렇지 않다면 중요하지 않은 기술적 문제에 정신이 팔려 있는 것인가?
- 왜 이것이 문제인가?
- 문제를 이렇게 풀기 어렵게 만드는 것이 무엇인가?
- 반드시 이 방법으로 해야 하는가?
- 반드시 해야 하는 일인가?

> 우리에게 필요한 것은 진짜 제약과 우리를 오도하는 제약 그리고 그 차이를 구별하기 위한 지혜다.

#### 준비가 되었을 때 시작하라.
- 말로 하는 반응이 잠재의식과 반사 신경을 훈련시켜서, 의식적으로 어떻게 그리고 왜 실력이 느는지 모르면서 실력이 는다는 것이 핵심
- 여러분의 수행 능력에 직감이 일조하도록 놓아두라.

#### 어떤 일들은 설명하기보다 실제로 하는 것이 쉽다.
- 요구사항의 모든 세부사항과 미묘한 차이점들을 모조리 잡아낼 수 있으리라고 믿는 것은 너무 순진한 생각이다.
- 언어 자체의 표현 능력에도 문제가 있다.
- 명세서를 만드는 것은 동의하지만 너무 자세하게 만드는 것보단 프로토타입이나 예광탄을 작성하라.

#### 형식적 방법의 노예가 되지 마라.
- 방법론이 제값을 하는가?
- 방법론의 노예가 되지 말라. 방법론을 비판적인 시각으로 바라본 다음, 각각의 방법론에서 가장 좋은 것만 뽑아 매달 점점 좋아지는 자신의 작업 실천 방법의 집합 속에 녹여 넣는다.

#### 비싼 도구가 더 좋은 설계를 낳지는 않는다.

#### 팀을 기능 중심으로 조직하라.
- 깨진 창문은 없애라, 소통하라. 반복하지마라.
- 팀 리더는 토론을 중재한다.

#### 수작업 절차를 사용하지 말라.
- 컴파일
- 코드 생성
- 쉘 스크립트
- 빌드 자동화


#### 일찍 테스트하고, 자주 테스트하라. 자동으로 테스트하라.
- 코드를 작성하자마자 테스트해야 한다.

#### 모든 테스트가 통과하기 전엔 코딩이 다 된 게 아니다.
- 단위 테스트
- 통합 테스트
- 유효성 평가와 검증
- 자원 고갈, 에러, 그리고 복구
    - 메모리
    - 디스크 공간
    - CPU 대역폭
    - 디스크 대역폭
    - 네트워크 대역폭
    - 우아하게 실패할 것인가? 할 수 있는 최선을 다해 현재 상태를 저장하고 작업 소실을 예방할 수 있을 것인가?
- 성능 테스트
    - 초당 예상 사용자 및 접속 혹은 트랜잭션 숫자를 염두에 두고 말이다.
- 사용편의성 테스트

#### 파괴자를 써서 테스트를 테스트하라.
- 버그가 의도적으로 생기도록 한 다음 테스트가 불평을 해대는지 확인하라.

> 테스팅은 버그의 존재만 보여줄 수 있지 버그의 부재까지는 보여줄 수 없다. - 다익스트라

#### 코드 커버리지보다 상태 커버리지를 테스트하라.
#### 버그는 한 번만 잡아라.
- 그건 앞으로 절대 다시 일어나지 않을 겁니다.
- 다음번에는 그걸 잡아낼 수 있도록 새 테스트를 추가해야 한다.

#### 모국어도 하나의 프로그래밍 언어인 것처럼 다루라.
#### 문서가 애초부터 전체의 일부가 되게 하고, 나중에 집어넣으려고 하지 말라.

#### 자신의 작품에 서명하라.
- 책임을 회피하지 않는다.
- 내가 이걸 만들었고, 내 작품의 품질을 보증합니다.

> 진정으로 Professional한 일. 진정한 Professional이 작성한. 실용주의 프로그래머 - 2018.08.13 Nesoy