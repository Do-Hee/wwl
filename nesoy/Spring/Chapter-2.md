# 테스트
- 객체지향과 테스트
- 테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.
- 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.

#### 단위 테스트
- 작은 단위의 코드에 대해 테스트를 수행한 것
- 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.
- DB의 상태가 매번 달라지고, 테스트를 위해 DB를 특정 상태로 만들어줄 수 없다면 그때는 단위 테스트로서 가치가 없어진다.
    - 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 하는 것이다.
- 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서이다.

#### 자동수행 테스트 코드
- 테스트는 자동으로 수행되고 빠르게 수행되어야 한다.
- 재빨리 확인하고, 수정하는 Cycle이 중요하다.


#### UserDaoTest 번거로움
- 사람의 눈으로 확인하는 과정이 아닌 테스트 코드로 결과도 자동으로 확인하기

#### Build Tool
- 빌드 스크립트를 이용해 Junit 테스트를 실행하고 그 결과를 메일 등으로 통보받는 방법을 사용하면 된다.


- Junit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다.
- 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.
- 개발자가 테스트를 직접 만들 때 자주 하는 실수가 하나 있다.
- 바로 성공하는 테스트만 골라서 만드는 것이다.
    - 항상 Negative Test를 먼저 만들라. - Spring 창시자 로드 존슨
    - 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는게 좋다.

#### TestCode에 나타난 기능
- 조건
- 행위
- 결과

## TDD(Test Driven Development)
- 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다.
- Cycle을 가능한 짧게 가져가도록 권장한다.
    - 테스트를 자주 하기 귀찮을 테고 테스트는 점점 뒤로 미뤄질 것이다.
- 개발한 코드의 오류는 빨리 발견할수록 좋다.
    - 빨리 발견된 오류는 쉽게 대응이 가능하기 때문이다.
- 어플리케이션 코드만이 리팩토링의 대상은 아니다.

## JUnit
- <https://nesoy.github.io/articles/2017-02/JUnit>

### Fixture
- 테스트를 수행하는 데 필요한 정보나 오브젝트를 Fixture라고 한다.
- 일반적으로 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다.


## 2.4 스프링 테스트 적용
- 테스트는 가능한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙이다.
- 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다.

```java
@RunWith(SpringJUnit4ClassRunner.class) // Spring Framework Junit 확장 지정
@ContextConfiguration(locations="/application.xml") // 테스트 컨텍스트가 자동으로 만들어줄 어플리케이션 컨텍스트의 위치 지정
public class UserDaoTest {
    @Autowired
    private ApplicationContext context; // 테스트 오브젝트가 만들어지면 스프링 테스트 컨텍스트에 의해 자동으로 값이 주입된다.
    @Before
    public void setUp() {
        this.dao = this.context.getBean("userDao", UserDao.class);
    }
}
```

#### @Autowired
- Spring DI에 사용되는 Annotation
- @Autowired가 붙은 인스턴스 변수가 있으면, Test Context Framework는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다.
- 스프링 Application Context는 초기화할 때 자기 자신도 Bean으로 등록한다.
- 단 @Autowired는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다.


#### @DirtiesContext
- 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다.
- Annotation이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다.
- 공유하는 것을 피하기 위해 매번 Application Context를 생성한다.
- Method Level도 가능하다.


### 테스트를 위한 별도의 DI 설정
- 코드가 많아져 번거롭기도 하고 애플리케이션 컨텍스트도 매번 새로 만들어야 하는 부담이 있다.

### 컨테이너 없는 테스트
- 스프링 컨테이너를 사용하지 않고 테스트 작성하기
- 테스트용 DataSource 오브젝트를 만들어 직접 DI 해주면 된다.

> DI를 위해 컨테이너가 반드시 필요한 것은 아니다. DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능하게 해주는 것은 아니다.

#### 침투적 기술과 비침투적 기술
- 침투적(invasive)기술은 기술을 적용했을 때 애플리케이션 코드에 기술 관련 API가 등장하거나, 특정 인터페이스나 클래스를 사용하도록 강제하는 기술을 말한다.
- 비침투적(noninvasive) 기술은 어플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능하다. 기술에 종속적이지 않은 순수한 코드를 유지할 수 있게 해준다.


> 테스트하기 좋은 코드가 좋은 코드일 가능성이 높다.


### DI를 이용한 테스트 방법 선택
- 스프링 컨테이너 없이 테스트
    - 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결.
- 스프링의 설정을 이용한 DI 방식의 테스트
    - 여러 Object와 복잡한 의존관계를 갖고 있는 Object를 테스트해야 할 경우
    - 개발 환경 : 테스트환경, 운영환경 -> 다른 설정파일을 만들어 사용하는 경우가 일반적
- @DirtiesContext 사용하여 테스트
    - 테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성해서 테스트해야 할 경우가 있다.


## 2.5 학습 테스트로 배우는 스프링
- 개발자가 자신이 만든 코드가 아닌 다른 사람이 만든 코드와 기능에 대한 테스트를 작성할 필요가 있을까?
    - 하지만 때로는 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 한다.
    - 이런 테스트를 Learning Test라고 한다.

### Learning Test
- 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것이다.
- 테스트이지만 프레임워크나 기능에 대한 검증이 목적이 아니다.
    - 오히려 자신이 테스트를 만들려고 하는 기술이나 기능에 대해 얼마나 제대로 이해하고 있는지, 그 사용 방법을 바로 알고 있는지를 검증하려는 게 목적이다.

#### 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
- 자동화된 테스트 코드로 만들어지기 때문에 다양한 조건에 따라 기능이 어떻게 동작하는지 빠르게 확인할 수 있다.


### Bug Test
- 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트
- QA팀의 테스트 중에 기능 오류가 발견됐다고 하자.
    - 코드를 뒤져가면서 수정하려고 하기보다는 먼저 버그 테스트를 만들어보는 편이 유용하다.
    - 일단 실패하도록 만들어야 한다.
    - 그러고 나서 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정한다.

#### 테스트의 완성도를 높여준다.
- 버그 테스트 덕분에 쉽게 추적이 가능해진다.

#### 버그의 내용을 명확하게 분석하게 해준다.
- 실패하기 위해선 어떤 이유 때문에 문제가 생겼는지 명확히 알아야 한다.
- 테스트의 중요한 기법 중의 하나인 동등분할이나 경계값 분석을 적용해볼 수도 있다.
    - 동등분할(equivalence partitioning) : 같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트를 하는 방법
    - 경계값 분석(boundary value analysis) : 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법이다.

#### 기술적인 문제를 해결하는 데 도움이 된다.
- 동일한 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트를 만들어보면 도움이 된다.


## 2.6 정리
- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
- 테스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안 된다.
- 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수 있다.
- 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
- 테스트하기 쉬운 코드가 좋은 코드다.
