# 템플릿
## 3.1 다시보는 초난감 DAO
- try/catch/finally 구문 사용을 권장하고 있다.
- 예외상황이 발생하여 자원 반납이 제대로 이뤄지지 않는다면 치명적인 문제가 될 수 있다.


## 3.2 변하는 것과 변하지 않는 것
- 테스트를 통해 DAO마다 예외상황에서 리소를 반납하는지 체크하게 했으면 어땠을까?
    - 좋은 생각이긴 한데 막상 적용하기는 쉽지 않을 것이다.
    - 매우 번거로운 일.
- 변하지 않는 부분, 변하는 부분을 분리하여 리팩토링을 한다.


### 템플릿 메소드 패턴
![No Image](/nesoy/Images/Spring/8.png)

- 변하지 않는 부분은 슈퍼클래스에 두고
- 변하는 부분은 추상 메소드로 정의해둬서 서브 클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.
- 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 있고, 확장 때문에 기존의 상위 DAO 클래스에 불필요한 변화는 생기지 않도록 할 수 있다.
- 단점은?
    - DAO로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점이다.
    - 확장 구조가 이미 클래스를 설계하는 시점에서 고정되어 버린다는 점이다.



### 전략 패턴
![No Image](/nesoy/Images/Spring/9.png)

- 오브젝트를 아예 둘로 분리하고 클래스 Level에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다.
- 새로운 기능이 추가된다면 외부의 독립된 전략 클래스에 위임하는 것이다.


### 마이크로 DI
- DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우를 마이크로 DI라고도 한다.


## 3.3 JDBC 전략 패턴의 최적화
- 클래스 파일이 많아지는 문제를 해결하기 위한 간단한 솔루션이 있다.
- 해당 클래스에서만 사용하고 있다면! -> 해당 내부 클래스로 선언하는 것이다.

### 중첩 클래스(nested class)의 종류
- static class : 독립적으로 오브젝트로 만들어 질 수 있는 클래스
- inner class : 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 클래스
    - member inner class : 멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스
    - local class : 메소드 레벨에 정의되는 클래스
    - annoymous inner class : 이름을 갖지 않는 익명 내부 클래스

![No Image](/nesoy/Images/Spring/10.png)


### 익명 내부 클래스(annoymous inner class)
- 이름을 갖지 않는 클래스
- new 인터페이스이름() { 클래스 본문 };


## 3.4 컨텍스트와 DI
- UserDAO의 종속적인 JDBC Context가 아닌 조금 더 추상적인 JDBC로 Refactoring
- Refactoring하다보니 의존관계를 연결하는 부분에 있어 인터페이스가 아닌 직접적인 클래스로 DI를 하고 있다.
    - 의존관계를 다이내믹하게 주입받고 싶으면 인터페이스를 정의하여 확장성있게 설계를 할 수도 있다.
- 하지만 인터페이스가 아닌 클래스를 사용하여 DI 구조를 구성하게 되었을까?
    - 싱글톤 Bean이 되기 때문이다.
    - 상태정보를 갖고 있지 않다. 그렇기에 하나의 싱글톤으로 등록돼서 여러 오브젝트에서 공유해 사용되는 것이 이상적이다.
    - JdbcContext가 DI를 통해 다른 빈에 의존하고 있기 때문이다.
        - 의존하고 있는 Bean을 DI 받기 위해서라도 스프링 빈으로 등록 돼야 한다.
    - 인터페이스가 없다는 건 클래스간의 매우 긴밀한 관계를 가지고 강하게 결합되어 있다는 의미다.
- 원한다면 인터페이스를 두고 설계해도 크게 문제는 없다.

- 코드를 이용하는 수동 DI
    - 싱글톤으로 만들려는 것은 포기해야 한다.
    - DAO마다 하나씩만 JdbcContext 오브젝트를 만들어 UserDAO가 DI를 직접 수행한다.
    - 내부에서 DI를 하기 때문에 그 관계를 외부에는 드러내지 않는다는 장점이 있다.
    - 필요에 따라 내부에서 은밀히 DI를 수행하고 그 전략을 외부에는 감출 수 있다.

![No Image](/nesoy/Images/Spring/11.png)



## 3.5 템플릿과 콜백
### 템플릿
- 어떤 목적을 위해 미리 만들어둔 모양이 있는 툴을 가리킨다.
- 고정된 틀 안에 바꿀 수 있는 부분을 넣어서 사용하는 경우에 템플릿이라고 한다.

### 콜백
- callback은 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말한다.

![No Image](/nesoy/Images/Spring/12.png)

- 콜백 오브젝트를 전달하는 것은 메소드 레벨에서 일어나는 DI다.
- 템플릿 / 콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법.

#### 템플릿과 콜백의 단점
- 매번 익명 내부 클래스를 사용하기 때문에 상대적으로 읽기 어려운 코드를 작성하는 불편한 점이 있다.


-------


- 변하는 것과 변하지 않는 것을 분리하고 변하지 않는 건 유연하게 재활용할 수 있게 만든다.
- 하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 응집력이 강한 코드들이기 때문에 한 군데 모여 있는게 유리하다.
- 구체적인 구현과 내부의 전략 패턴, 코드에 의한 DI, 익명 내부 클래스 등의 기술은 최대한 감춰두고, 꼭 외부에 필요한 기능을 제공하는 단순한 메소드만 노출해주는 것이다.

> 스프링에 내장된 것을 원리도 알지 못한 채로 기계적으로 사용하는 경우와 적용된 패턴을 이해하고 사용하는 경우는 큰 차이가 있다.

- 중복되는 코드를 분리할 방법을 생각해보는 습관을 기르자.
    - 메소드로 분리하는 간단한 시도.
    - 일부 작업을 필요에 따라 바꾸어 사용해야 한다면?
        - 인테페이스를 사이에 두고 분리해서 전략 패턴을 적용하고 DI로 의존관계를 관리하도록 만든다.
    - 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어질 수 있다면?
        - 템플릿 / 콜백 패턴을 적용하는 것을 고려해볼 수 있다.

> 현재 자바 8에서는 Lambda Expression이 가능하기에.. 익명 내부 클래스 대신 Function Parameter으로 대체가 가능할 것으로 보인다.

- 템플릿/ 콜백을 적용할떄는 템플릿과 콜백의 경계를 정하고 템플릿이 콜백에게, 콜백이 템플릿에게 각각 전달하는 내용이 무엇인지 파악하는게 가장 중요하다. 그에 따라 인터페이스를 정의해야 하기 때문이다.


## 3.6 스프링의 JdbcTemplate
- JDBC API를 사용하는 방식, 예외처리, 리소스의 반납, DB 연결을 어떻게 가져올지에 관한 책임과 관심은 모두 JdbcTemplate에게 있다.
- 따라서 변경이 일어난다고 해도 UserDao코드에는 아무런 영향을 주지 않는다.


## 3.7 정리
- 리소스의 반환이 필요한 코드는 반드시 try/catch/finally 블록으로 관리해야 한다.
- 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용한다.

> 템플릿/콜백은 스프링이 객체지향 설계와 프로그래밍에 얼마나 가치를 두고 있는지를 잘 보여주는 예다.